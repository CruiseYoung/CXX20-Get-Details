\begin{center}
\includegraphics[width=0.3\textwidth]{content/3/chapter5/images/18.png}\\
Cippi在研究日历
\end{center}

\begin{tcolorbox}[breakable,enhanced jigsaw,colback=blue!5!white,colframe=blue!75!black,title={缺少编译器支持}]
	
截止到2020年底，还没有C++编译器支持chrono扩展。感谢HowardHinnant的原型库\href{https://github.com/HowardHinnant/date}{date}，它本质上是C++20中扩展时间功能的超集，我对它做了一些实验。该库托管在GitHub上，使用date原型的方法有很多:

\begin{itemize}
\item 
可以在Wandbox上试试。Howard已经上传了date.h头文件，这足以使用新的类型std::time\_of\_day和日历。下面是Howard给出的链接:\href{https://wandbox.org/permlink/L8MwjzSSC3fXXrMd}{在Wandbox上试一试吧!}。

\item 
下载项目并构建它，GitHub上\href{https://github.com/HowardHinnant/date}{date}提供了更多信息。想要尝试新的时区特性时，需要进行此步骤。
\end{itemize}

本章的例子使用Howard Hinnant的库。不过，我的解释是基于C++20术语的。当C++编译器支持扩展的chrono功能时，我将使示例适配C++20的语法。

\end{tcolorbox}

\begin{itemize}
\item 
一天中的时间是指从午夜开始的时间长度，分为小时、分钟、秒和分数秒。

\item 
Calendar表示各种日历日期，如年、月、工作日或一周的第n天。

\item 
时区表示特定于地理区域的时间。
\end{itemize}

时区功能(C++20)是基于日历功能(C++20)，而日历功能(C++20)是基于时间功能(C++11)。


\begin{tcolorbox}[breakable,enhanced jigsaw,colback=blue!5!white,colframe=blue!75!black,title={C++11的时间库}]
	
为了充分利用本节的内容，必须先对chrono库有基本的了解。C++11引入了三个主要组件来处理时间:

\begin{itemize}
\item 
时间点由时间起点(即所谓的epoch)和持续时间定义。

\item 
时间间隔由两个时间点之间的差值，使用时钟周期数表示。

\item 
时钟由时间起点(epoch)和时钟周期数组成，可以计算出当前的时间点。
\end{itemize}

老实说，时间对我来说是个谜。一方面，每个人对时间都有一个直观的概念，另一方面，正式定义它极具挑战性。例如，时间点(time point)、持续时间(time duration)和时钟(clock)三者相互依赖。若想了解更多C++11中有关时间的功能，请阅读我在\href{https://www.modernescpp.com/index.php/tag/time}{time}上发布的关于时间的文章。
	
\end{tcolorbox}

\subsubsubsection{5.5.1\hspace{0.2cm}日期}

std::chrono::hh\_mm\_ss是自午夜开始的持续时间，分为小时、分钟、秒和分数秒，这种类型通常用作格式化工具。下表提供了std::chrono::hh\_mm\_ss实例tOfDay的简明概述。

\begin{center}
日期
\end{center}

\begin{table}[H]
\centering
\begin{tabular}{ll}
\textbf{函数}         & \textbf{描述}                        \\ \hline
tOfDay.hours()            & 返回从午夜开始累计的小时数   \\
tOfDay.minutes()          & 返回从午夜开始累计的分钟数 \\
tOfDay.seconds()          & 返回从午夜开始累计的秒数 \\
tOfDay.subseconds()       & 返回从午夜开始累计的分秒数  \\
tOfDay.to\_duration()     & 返回从午夜以来的持续时间    \\
std::chrono::make12(hour) & 返回12小时的等价24小时的时间格式 \\
std::chrono::make24(hour) & 返回24小时的等价12小时的时间格式 \\
std::chrono::is\_am(hour) & 检测24小时时间格式是否为a.m.  \\
std::chrono::is\_pm(hour) & 检测24小时时间格式是否为p.m.
\end{tabular}
\end{table}

这些函数的使用起来很简单。

\begin{lstlisting}[style=styleCXX]
// timeOfDay.cpp

#include "date.h"
#include <iostream>

int main() {
	using namespace date;    
	
	using namespace std::chrono_literals;
	
	std::cout << std::boolalpha << '\n';
	auto timeOfDay = date::hh_mm_ss(10.5h + 98min + 2020s + 0.5s);
	
	std::cout<< "timeOfDay: " << timeOfDay << '\n';
	
	std::cout << '\n';
	
	std::cout << "timeOfDay.hours(): " << timeOfDay.hours() << '\n';
	std::cout << "timeOfDay.minutes(): " << timeOfDay.minutes() << '\n';
	std::cout << "timeOfDay.seconds(): " << timeOfDay.seconds() << '\n';
	std::cout << "timeOfDay.subseconds(): " << timeOfDay.subseconds() << '\n';
	std::cout << "timeOfDay.to_duration(): " << timeOfDay.to_duration() << '\n';
	std::cout << '\n';
	
	std::cout << "date::hh_mm_ss(45700.5s): " << date::hh_mm_ss(45700.5s) << '\n';
	
	std::cout << '\n';
	
	std::cout << "date::is_am(5h): " << date::is_am(5h) << '\n';
	std::cout << "date::is_am(15h): " << date::is_am(15h) << '\n';
	
	std::cout << '\n';
	
	std::cout << "date::make12(5h): " << date::make12(5h) << '\n';
	std::cout << "date::make12(15h): " << date::make12(15h) << '\n';

}
\end{lstlisting}

首先，我在第12行创建了std::chrono::hh\_mm\_ss: timeOfDay的一个新实例。C++14添加了chrono字面值，就可以添加一些时间持续时间来初始化一天中的时间对象。使用C++20，可以直接输出timeOfDay(第14行)，这就是我必须在第7行中引入命名空间date的原因。其余部分应该很容易阅读。第18-21行，以小时、分钟、秒和分数秒为单位显示了从午夜开始的时间分量。第22行返回自午夜以来的时间持续时间，以秒为单位。第26行更有趣:给定的秒对应于第15行中显示的时间。若给定的时间是a.m.，则返回第30和32行。第35行和36行返回与给定小时等价12小时的时间格式。

下面是程序的输出:

\begin{tcblisting}{commandshell={}}
timeOfDay: 12:41:40.500000

timeOfDay.hours(): 12h
timeOfDay.minutes(): 41min
timeOfDay.seconds(): 40s
timeOfDay.subseconds(): 0.500000s
timeOfDay.to_duration(): 45700.500000s

date::hh_mm_ss(45700.5s): 12:41:40.500000

date::is_am(5h): true
date::is_am(15h): false

date::make12(5h): 5h
date::make12(15h): 3h
\end{tcblisting}

\subsubsubsection{5.5.2\hspace{0.2cm}日历日期}

C++20中一个新的chrono扩展类型是日历日期。C++20支持多种方式来创建日历日期，并可以与之交互。那什么是日历日期呢?

日历日期是由一年、一个月和一天组成的日期。因此，C++20有一个特定的数据类型std::chrono::year\_month\_day。C++20提供了很多相关的功能。在下面的表中，将了解日历日期类型，然后再展示各种方式的用例。

\begin{center}
各种日历日期类型
\end{center}

\begin{table}[H]
\centering
\begin{tabular}{ll}
\textbf{类型}                 & \textbf{描述}                                   \\ \hline
std::chrono::last\_spec       & 一个月的最后一天或工作日           \\
std::chrono::day              & 一个月中的一天                            \\
std::chrono::month            & 一年中的一个月                           \\
std::chrono::year             & 表示公历中的一年            \\
std::chrono::weekday          & 表示公历中的一周中的一天 \\
std::chrono::weekday\_indexed & 表示每月的第n个工作日                 \\
std::chrono::weekday\_last    & 表示一个月的最后一个工作日                 \\
std::chrono::month\_day       & 表示特定月份中的特定日期          \\
std::chrono::month\_day\_last & 表示特定月份的最后一天            \\
std::chrono::month\_weekday   & 表示特定月份的第n个工作日        \\
std::chrono::month\_weekday\_last            & 表示特定月份的最后一个工作日           \\
std::chrono::year\_month      & 表示特定年份中的特定月份         \\
std::chrono::year\_month\_day & 表示特定的年、月和日             \\
std::chrono::year\_month\_day\_last          & 表示特定年份和月份的最后一天      \\
std::chrono::year\_month\_weekday            & 表示特定年份和月份的第n个工作日  \\
std::chrono::year\_month\_day\_weekday\_last & 表示特定年份和月份的最后一个工作日 \\
std::chrono::operator /       & 创建公历日期              
\end{tabular}
\end{table}

现从简单的开始，创建几个日历日期。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.2.1\hspace{0.2cm}创建日历日期}

createCalendar.cpp展示了创建日历相关日期的各种方法。

\begin{lstlisting}[style=styleCXX]
// createCalendar.cpp

#include <iostream>
#include "date.h"

int main() {

	std::cout << '\n';
	
	using namespace date;
	
	constexpr auto yearMonthDay{year(1940)/month(6)/day(26)};
	std::cout << yearMonthDay << " ";
	std::cout << date::year_month_day(1940_y, June, 26_d) << '\n';
	
	std::cout << '\n';
	
	constexpr auto yearMonthDayLast{year(2010)/March/last};
	std::cout << yearMonthDayLast << " ";
	std::cout << date::year_month_day_last(2010_y, month_day_last(month(3))) << '\n';
	
	constexpr auto yearMonthWeekday{year(2020)/March/Thursday[2]};
	std::cout << yearMonthWeekday << " ";
	std::cout << date::year_month_weekday(2020_y, month(March), Thursday[2]) << '\n';
	
	constexpr auto yearMonthWeekdayLast{year(2010)/March/Monday[last]};
	std::cout << yearMonthWeekdayLast << " ";
	std::cout << date::year_month_weekday_last(2010_y, month(March),
	weekday_last(Monday)) << '\n';
	
	std::cout << '\n';
	
	constexpr auto day_{day(19)};
	std::cout << day_ << " ";
	std::cout << date::day(19) << '\n';
	
	constexpr auto month_{month(1)};
	std::cout << month_ << " ";
	std::cout << date::month(1) << '\n';
	
	constexpr auto year_{year(1988)};
	std::cout << year_ << " ";
	std::cout << date::year(1988) << '\n';
	
	constexpr auto weekday_{weekday(5)};
	std::cout << weekday_ << " ";
	std::cout << date::weekday(5) << '\n';
	
	constexpr auto yearMonth{year(1988)/1};
	std::cout << yearMonth << " ";
	std::cout << date::year_month(year(1988), January) << '\n';
	
	constexpr auto monthDay{10/day(22)};
	std::cout << monthDay << " ";
	std::cout << date::month_day(October, day(22)) << '\n';
	
	constexpr auto monthDayLast{June/last};
	std::cout << monthDayLast << " ";
	std::cout << date::month_day_last(month(6)) << '\n';
	
	constexpr auto monthWeekday{2/Monday[3]};
	std::cout << monthWeekday << " ";
	std::cout << date::month_weekday(February, Monday[3]) << '\n';
	
	constexpr auto monthWeekDayLast{June/Sunday[last]};
	std::cout << monthWeekDayLast << " ";
	std::cout << date::month_weekday_last(June, weekday_last(Sunday)) << '\n';
	
	std::cout << '\n';

}
\end{lstlisting}

There are essentially two ways to create a calendar date. You can use the so-called cute syntax yearMonthDay\{year(1940)/month(6)/day(26)\} (line 12), or you can use the explicit type date::year\_month\_day(1940y, June, 26d) (line 14). In order not to overwhelm you, I will delay my explanation of the cute syntax to the next section. The explicit type is quite interesting, because it uses the date-time literals 1940y, 26d, and the predefined constant June. This was the obvious part of the program.

Line 18, line 22, and line 26 offer further ways to create calendar dates.

\begin{enumerate}
\item 
Line 18: the last day of March 2010: 
\begin{lstlisting}[style=styleCXX]
{year(2010)/March/last}
\end{lstlisting}
or
\begin{lstlisting}[style=styleCXX]
year_month_day_last(2010y, month_day_last(month(3)))
\end{lstlisting}

\item 
Line 22: the second Thursday of March 2020:
\begin{lstlisting}[style=styleCXX]
{year(2020)/March/Thursday[2]}
\end{lstlisting}
or
\begin{lstlisting}[style=styleCXX]
year_month_weekday(2020y, month(March), Thursday[2])
\end{lstlisting}

\item 
Line 26: the last Monday of March 2010: 
\begin{lstlisting}[style=styleCXX]
{year(2010)/March/Monday[last]}
\end{lstlisting}
or
\begin{lstlisting}[style=styleCXX]
year_month_weekday_last(2010y, month(March), weekday_last(Monday))
\end{lstlisting}
\end{enumerate}

The remaining calendar types stand for a day (line 33), a month (line 37), or a year (line 41). You can combine and use them as basic building blocks for fully specified calendar dates, such as in lines 18, 22, or 26.

This is the output of the program:

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/20.png}\\
Various calendar days
\end{center}

As promised, let me write about the cute syntax.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.2.2\hspace{0.2cm} Cute Syntax}

The cute syntax consists of overloaded division operators to specify a calendar date. The overloaded operators support time literals (e.g.: 2020y, 31d) and constants (January, February, March, April, May, June, July, August, September, October, November, December).

The following three combinations of year, month, and day are possible when you use the cute syntax.

\hspace*{\fill} \\ %插入空行
\noindent
Cute syntax
\begin{lstlisting}[style=styleCXX]
year/month/day
day/month/year
month/day/year
\end{lstlisting}

These combinations are not arbitrarily chosen. They are the ones used worldwide. Any other combination is not allowed.

Consequently, when you choose the type year, month, or day for the first argument, the type for the remaining two arguments is no longer necessary anymore, and a number would do the job.

\hspace*{\fill} \\ %插入空行
\noindent
Cute syntax
\begin{lstlisting}[style=styleCXX]
// cuteSyntax.cpp

#include <iostream>
#include "date.h"

int main() {
	
	std::cout << '\n';
	
	using namespace date;
	
	constexpr auto yearMonthDay{year(1966)/6/26};
	std::cout << yearMonthDay << '\n';
	
	constexpr auto dayMonthYear{day(26)/6/1966};
	std::cout << dayMonthYear << '\n';
	
	constexpr auto monthDayYear{month(6)/26/1966};
	std::cout << monthDayYear << '\n';
	
	constexpr auto yearDayMonth{year(1966)/month(26)/6};
	std::cout << yearDayMonth << '\n';
	
	std::cout << '\n';

}
\end{lstlisting}

The combination year/day/month (line 21) is not allowed and causes a run-time message.

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/21.png}\\
Use of cute syntax
\end{center}

I assume you want to display a calendar date \{year(2010)/March/last\} in a readable form, for example, 2020-03-31. This is a job for the local\_days or sys\_days operator.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.2.3\hspace{0.2cm} Displaying Calendar Dates}

Thanks to std::chrono::local\_days or std::chrono::sys\_days, you can convert calendar dates to a std::chrono::time\_point. I use std::chrono::sys\_days in my example. std::chrono::sys\_days is based on \href{https://en.cppreference.com/w/cpp/chrono/system_clock}{std::chrono::system\_clock}. Let me convert the calendar dates (lines 18, 22, and 26) from the previous program createCalendar.cpp.

\hspace*{\fill} \\ %插入空行
\noindent
Displaying calendar dates
\begin{lstlisting}[style=styleCXX]
 // sysDays.cpp

#include <iostream>
#include "date.h"

int main() {

	std::cout << '\n';
	
	using namespace date;
	
	constexpr auto yearMonthDayLast{year(2010)/March/last};
	std::cout << "sys_days(yearMonthDayLast): "
	<< sys_days(yearMonthDayLast) << '\n';
	
	constexpr auto yearMonthWeekday{year(2020)/March/Thursday[2]};
	std::cout << "sys_days(yearMonthWeekday): "
	<< sys_days(yearMonthWeekday) << '\n';
	
	constexpr auto yearMonthWeekdayLast{year(2010)/March/Monday[last]};
	std::cout << "sys_days(yearMonthWeekdayLast): "
	<< sys_days(yearMonthWeekdayLast) << '\n';
	
	std::cout << '\n';
	
	constexpr auto leapDate{year(2012)/February/last};
	std::cout << "sys_days(leapDate): " << sys_days(leapDate) << '\n';
	
	constexpr auto noLeapDate{year(2013)/February/last};
	std::cout << "sys_day(noLeapDate): " << sys_days(noLeapDate) << '\n';
	
	std::cout << '\n';

}
\end{lstlisting}

The std::chrono::last constant (line 11) lets me easily determine how many days a month has. The output shows that 2012 is a leap year (line 26), but not 2013 (line 29).

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/22.png}\\
Displaying calendar dates
\end{center}

Assume you have a calendar date such as year(2100)/2/29. Your first question may be: Is this date valid?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.2.4\hspace{0.2cm} Check if a Date is valid}

The various calendar types in C++20 have a function ok. This function returns true if the date is valid.

\hspace*{\fill} \\ %插入空行
\noindent
Checking if a date is valid
\begin{lstlisting}[style=styleCXX]
// leapYear.cpp

#include <iostream>
#include "date.h"

int main() {
	
	std::cout << std::boolalpha << '\n';
	
	using namespace date;
	
	std::cout << "Valid days" << '\n';
	day day31(31);
	day day32 = day31 + days(1);
	std::cout << " day31: " << day31 << "; ";
	std::cout << "day31.ok(): " << day31.ok() << '\n';
	std::cout << " day32: " << day32 << "; ";
	std::cout << "day32.ok(): " << day32.ok() << '\n';
	
	
	std::cout << '\n';
	
	std::cout << "Valid months" << '\n';
	month month1(1);
	month month0(0);
	std::cout << " month1: " << month1 << "; ";
	std::cout << "month1.ok(): " << month1.ok() << '\n';
	std::cout << " month0: " << month0 << "; ";
	std::cout << "month0.ok(): " << month0.ok() << '\n';
	
	std::cout << '\n';
	
	std::cout << "Valid years" << '\n';
	year year2020(2020);
	year year32768(-32768);
	std::cout << " year2020: " << year2020 << "; ";
	std::cout << "year2020.ok(): " << year2020.ok() << '\n';
	std::cout << " year32768: " << year32768 << "; ";
	std::cout << "year32768.ok(): " << year32768.ok() << '\n';
	
	std::cout << '\n';
	
	std::cout << "Leap Years" << '\n';
	
	constexpr auto leapYear2016{year(2016)/2/29};
	constexpr auto leapYear2020{year(2020)/2/29};
	constexpr auto leapYear2024{year(2024)/2/29};
	
	std::cout << " leapYear2016.ok(): " << leapYear2016.ok() << '\n';
	std::cout << " leapYear2020.ok(): " << leapYear2020.ok() << '\n';
	std::cout << " leapYear2024.ok(): " << leapYear2024.ok() << '\n';
	
	std::cout << '\n';
	
	std::cout << "No Leap Years" << '\n';
	
	constexpr auto leapYear2100{year(2100)/2/29};
	constexpr auto leapYear2200{year(2200)/2/29};
	constexpr auto leapYear2300{year(2300)/2/29};
	
	std::cout << " leapYear2100.ok(): " << leapYear2100.ok() << '\n';
	std::cout << " leapYear2200.ok(): " << leapYear2200.ok() << '\n';
	std::cout << " leapYear2300.ok(): " << leapYear2300.ok() << '\n';
	
	std::cout << '\n';
	
	std::cout << "Leap Years" << '\n';
	
	constexpr auto leapYear2000{year(2000)/2/29};
	constexpr auto leapYear2400{year(2400)/2/29};
	constexpr auto leapYear2800{year(2800)/2/29};
	
	std::cout << " leapYear2000.ok(): " << leapYear2000.ok() << '\n';
	std::cout << " leapYear2400.ok(): " << leapYear2400.ok() << '\n';
	std::cout << " leapYear2800.ok(): " << leapYear2800.ok() << '\n';
	
	std::cout << '\n';

}
\end{lstlisting}

I check in the program if a given day (line 12), a given month (line 23), or a given year (line 33) is valid. The range of a day is [1, 31], of a month [1, 12], and of a year [ -32767, 32767]. Consequently, the ok() calls on the corresponding values returns false. Two facts are interesting when I display various values. First, if the value is not valid, the output displays: “is not a valid day”, “is not a valid month”, “is not a valid year”. Second, month values are displayed in string representation.

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/23.png}\\
Check if a data is valid
\end{center}

You can apply the ok-call on a calendar date. Now it’s quite easy to check if a specific calendar date is a leap day and, therefore, the corresponding year a leap year. In the worldwide used \href{https://en.wikipedia.org/wiki/Gregorian_calendar}{Gregorian calendar}, the following rules apply:

Each year that is exactly divisible by 4 is a leap year.
 
\begin{itemize}
\item 
Except for years which are exactly divisible by 100. They are not leap years.

\begin{itemize}
\item 
Except for years which are exactly divisible by 400. They are leap years.
\end{itemize}
\end{itemize}

Too complicated? The program leapYears.cpp exemplifies this rule.

The extended chrono library makes it quite easy to ask for the time duration between calendar dates.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.2.5\hspace{0.2cm} Query Calendar Dates}

Without further ado. The following program queryCalendarDates.cpp queries a few calendar dates.

\hspace*{\fill} \\ %插入空行
\noindent
Query calendar dates
\begin{lstlisting}[style=styleCXX]
// queryCalendarDates.cpp

#include "date.h"
#include <iostream>

int main() {
	
	using namespace date;
	
	std::cout << '\n';
	
	auto now = std::chrono::system_clock::now();
	std::cout << "The current time is: " << now << " UTC\n";
	std::cout << "The current date is: " << floor<days>(now) << '\n';
	std::cout << "The current date is: " << year_month_day{floor<days>(now)}
	<< '\n';
	std::cout << "The current date is: " << year_month_weekday{floor<days>(now)}
	<< '\n';
	
	std::cout << '\n';
	
	
	auto currentDate = year_month_day(floor<days>(now));
	auto currentYear = currentDate.year();
	std::cout << "The current year is " << currentYear << '\n';
	auto currentMonth = currentDate.month();
	std::cout << "The current month is " << currentMonth << '\n';
	auto currentDay = currentDate.day();
	std::cout << "The current day is " << currentDay << '\n';
	
	std::cout << '\n';
	
	auto hAfter = floor<std::chrono::hours>(now) - sys_days(January/1/currentYear);
	std::cout << "It has been " << hAfter << " since New Year!\n";
	
	auto nextYear = currentDate.year() + years(1);
	auto nextNewYear = sys_days(January/1/nextYear);
	auto hBefore = sys_days(January/1/nextYear) - floor<std::chrono::hours>(now);
	std::cout << "It is " << hBefore << " before New Year!\n";
	
	std::cout << '\n';
	
	std::cout << "It has been " << floor<days>(hAfter) << " since New Year!\n";
	std::cout << "It is " << floor<days>(hBefore) << " before New Year!\n";
	
	std::cout << '\n';
	
}
\end{lstlisting}

With the C++20 extension, you can directly display a time point, such as now (line 12). std::chrono::floor converts the time point to a day std::chrono::sys\_days. This value can be used to initialize the calendar type std::chrono::year\_month\_day. Finally, when I put the value into a std::chrono::year\_month\_weekday calendar type, I get the answer that this specific day is the 3rd Tuesday in October. Of course, I can also ask a calendar date for its components, such as the current year, month, or day (line 23).

Line 33 is the most interesting one. When I subtract from the current date, using hour resolution, the first of January of the current year, I get the number of hours since the new year. Conversely, when I subtract from the first of January of the next year (line 37) the current date, using hour resolution, I get the hours to the new year. Maybe you don’t like hour resolution. Line 42 and 43 display the values using day resolution.

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/24.png}\\
Query calendar days
\end{center}

Now, I want to know the day of the week of my birthday.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.2.6\hspace{0.2cm} Query Weekdays}

Thanks to the extended chrono library, it is quite easy to get the weekday of a given calendar date.

\hspace*{\fill} \\ %插入空行
\noindent
Weekdays of given calendar dates
\begin{lstlisting}[style=styleCXX]
// weekdaysOfBirthdays.cpp

#include <cstdlib>
#include <iostream>
#include "date.h"

int main() {
	
	std::cout << '\n';
	
	using namespace date;
	
	int y;
	int m;
	int d;
	
	std::cout << "Year: ";
	std::cin >> y;
	std::cout << "Month: ";
	std::cin >> m;
	std::cout << "Day: ";
	std::cin >> d;
	
	std::cout << '\n';
	
	auto birthday = year(y)/month(m)/day(d);
	
	if (not birthday.ok()) {
		std::cout << birthday << '\n';
		std::exit(EXIT_FAILURE);
	}
	
	std::cout << "Birthday: " << birthday << '\n';
	auto birthdayWeekday = year_month_weekday(birthday);
	std::cout << "Weekday of birthday: " << birthdayWeekday.weekday() << '\n';
	
	auto currentDate = year_month_day(floor<days>(
	std::chrono::system_clock::now()));
	auto currentYear = currentDate.year();
	
	auto age = (int)currentDate.year() - (int)birthday.year();
	std::cout << "Your age: " << age << '\n';
	
	std::cout << '\n';
	
	std::cout << "Weekdays for your next 10 birthdays" << '\n';
	
	for (int i = 1, newYear = (int)currentYear; i <= 10; ++i ) {
		std::cout << " Age " << ++age << '\n';
		auto newBirthday = year(++newYear)/month(m)/day(d);
		std::cout << " Birthday: " << newBirthday << '\n';
		std::cout << " Weekday of birthday: "
				  << year_month_weekday(newBirthday).weekday() << '\n';
	}
	
	std::cout << '\n';
	
}
\end{lstlisting}

First, the program asks you for the year, month, and day of your birthday (line 17). Based on the input, a calendar date is created (line 26) and checked if it’s valid (line 28). Now I display the weekday of your birthday. I use the calendar date to fill the calendar type std::chrono::year\_month\_weekday (line 34). To get the int representation of the calendar type year, I have to convert it to int (line 41). Now I can display your age. Finally, the for loop displays, for each of your next ten birthdays (line 46), the following information: your age, the calendar date, and the weekday. I just have to increment the age and newYear variable.

Here is a run of the program with my birthday.

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/25.png}\\
Weekdays of birthdays
\end{center}

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.2.7\hspace{0.2cm} Calculating Ordinal Dates}

As a last example of the new calendar facility, I want to present the online resource \href{https://github.com/HowardHinnant/date/wiki/Examples-and-Recipes}{Examples and Recipes} from Howard Hinnant, which has about 40 examples of the new chrono functionality. Presumably, the chrono extension in C++20 is not easy to get, therefore it’s quite important to have so many examples. You should use these examples as a starting point for further experiments and, therefore, sharpen your understanding. You can also add your recipes.

To get an idea of Examples and Recipes I want to present a program by \href{https://github.com/rbock}{Roland Bock} that calculates ordinal dates.

“An ordinal date consists of a year and a day of year (1st of January being day 1, 31st of December being day 365 or day 366). The year can be obtained directly from year\_month\_day. And calculating the day is wonderfully easy. In the code below we make us of the fact that year\_month\_day can deal with invalid dates like the 0th of January:” (Roland Bock) I added the necessary headers to Roland’s program.

\hspace*{\fill} \\ %插入空行
\noindent
Calculating ordinal dates
\begin{lstlisting}[style=styleCXX]
// ordinalDate.cpp

#include "date.h"
#include <iomanip>
#include <iostream>

int main()
{
	using namespace date;
	
	const auto time = std::chrono::system_clock::now();
	const auto daypoint = floor<days>(time);
	const auto ymd = year_month_day{daypoint};
	
	// calculating the year and the day of the year
	const auto year = ymd.year();
	const auto year_day = daypoint - sys_days{year/January/0};
	
	std::cout << year << '-' << std::setfill('0') << std::setw(3)
	          << year_day.count() << '\n';
	
	// inverse calculation and check
	assert(ymd == year_month_day{sys_days{year/January/0} + year_day});
}
\end{lstlisting}

I want to make a few remarks about the program. Line 12 truncates the current time point. The value is used in the following line to initialize a calendar date. Line 17 calculates the time duration between the two time points. Both time points have the resolution day. Finally, year\_day.count() in line 19 returns the time duration in days.

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/26.png}\\
Caculating ordinal dates
\end{center}

\subsubsubsection{5.5.3\hspace{0.2cm} Time Zones}

First of all, a time zone is a region, and its full history of the date, such as daylight saving time or leap seconds. The time zone library in C++20 is a complete parser of the \href{https://www.iana.org/timezones}{IANA timezone database}. The following table should give you a first idea of the new functionality.

\begin{center}
The time-zone data types
\end{center}

\begin{table}[H]
\centering
\begin{tabular}{ll}
\textbf{Type}                         & \textbf{Description}                                              \\ \hline
std::chrono::tzdb                     & Describes a copy of the IANA time-zone database                   \\
std::chrono::tdzb\_list               & Represents a linked list of the tzdb                              \\
\begin{tabular}[c]{@{}l@{}}std::chrono::get\_tzdb \\ std::chrono::get\_tzdb\_list \\ std::chrono::reload\_tzdb \\ std::chrono::remote\_version\end{tabular} &
Accesses and controls the global time-zone database \\
std::chrono::locate\_zone             & Locates the time zone based on its name                           \\
std::chrono::current\_zone            & Returns the current time zone                                     \\
std::chrono::time\_zone               & Represents a time zone                                            \\
std::chrono::sys\_info                & Represents information about a time zone at a specific time point \\
std::chrono::local\_info              & Represents information about a local time to UNIX time conversion \\
std::chrono::zoned\_traits            & Class for time zone pointers                                      \\
std::chrono::zoned\_time              & Represents a time zone and a time point                           \\
std::chrono::leap\_second             & Contains information about a leap-second insertion                \\
std::chrono::time\_zone\_link         & Represents an alternative name for a time zone                    \\
std::chrono::nonexistent\_local\_time & Exception which is thrown if a local time does not exist         
\end{tabular}
\end{table}

I use in my examples the function std::chrono::zones\_time, which is essentially a time zone combined with a time point.

\begin{tcolorbox}[breakable,enhanced jigsaw,colback=blue!5!white,colframe=blue!75!black,title={Compilation of the examples}]
	
Before I show you two examples, I want to make a short remark. To compile a program using the time zone library, you have to compile the tz.cpp file from the \href{https://github.com/HowardHinnant/date}{date} library and link it against the \href{https://curl.se/}{curl} library. The curl library is necessary to get the current \href{https://www.iana.org/timezones}{IANA timezone database}. The following command line for g++ should give you the idea:

\hspace*{\fill} \\ %插入空行
\noindent
Compilation with the prototype library date
\begin{tcblisting}{commandshell={}}
g++ localTime.cpp -I <Path to data/tz.h> tz.cpp -std=c++17 \
  -lcurl -o localTime
\end{tcblisting}

\end{tcolorbox}

My first example is straightforward. It displays the UTC time and the local time.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.3.1\hspace{0.2cm} UTC Time and Local Time}

The \href{https://en.wikipedia.org/wiki/Coordinated_Universal_Time}{UTC time or Coordinated Universal Time} is the primary time standard worldwide. A computer uses \href{https://en.wikipedia.org/wiki/Unix_time}{Unix time} which is a very close approximation of UTC. The UNIX time is the number of seconds since the Unix epoch. The Unix epoch is 00:00:00 UTC on 1 January 1970.

std::chrono::system\_clock::now() returns in the program localTime.cpp the Unix time.

\hspace*{\fill} \\ %插入空行
\noindent
Getting the UTC time and local time
\begin{lstlisting}[style=styleCXX]
// localTime.cpp

#include "date/tz.h"
#include <iostream>

int main() {

	std::cout << '\n';
	
	using namespace date;
	
	std::cout << "UTC time" << '\n';
	auto utcTime = std::chrono::system_clock::now();
	std::cout << " " << utcTime << '\n';
	std::cout << " " << date::floor<std::chrono::seconds>(utcTime) << '\n':
	
	std::cout << '\n';
	
	std::cout << "Local time" << '\n';
	auto localTime = date::make_zoned(date::current_zone(), utcTime);
	std::cout << " " << localTime << '\n';
	std::cout << " " << date::floor<std::chrono::seconds>(localTime.get_local_time())
	          << '\n';
	
	auto offset = localTime.get_info().offset;
	std::cout << " UTC offset: " << offset << '\n';

	std::cout << '\n';

}
\end{lstlisting}

The code block beginning with line 12 gets the current time point, truncates it to seconds, and displays it. The call make\_zoned (line 20) creates a std::chrono::zoned\_time localTime. After that, the call localTime.get\_local\_time() returns the stored time point as a local time. This time point is also truncated to seconds. localTime (line 25) can also be used to get information about the time zone. In this case, I’m interested in the offset to the UTC time.

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/27.png}\\
Displaying UTC time and local time
\end{center}

My last example answers a crucial question when I teach in a different time zone: When should I start my online class?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.3.2\hspace{0.2cm} Various Time Zones for Online Classes}

The program onlineClass.cpp answers the following question: How late is it in given time zones, when I start an online class at the 7h, 13h, or 17h local time (Germany)?

The online class should start on the 1st of February 2021 and should take four hours. Because of daylight saving time, the calendar date is essential to get the correct answer.

\hspace*{\fill} \\ %插入空行
\noindent
Calculating the time in different time zones
\begin{lstlisting}[style=styleCXX]
// onlineClass.cpp

#include "date/tz.h"
#include <algorithm>
#include <iomanip>
#include <iostream>

template <typename ZonedTime>
auto getMinutes(const ZonedTime& zonedTime) {
	return date::floor<std::chrono::minutes>(zonedTime.get_local_time());
}

void printStartEndTimes(const date::local_days& localDay,
						const std::chrono::hours& h,
						const std::chrono::hours& durationClass,
						const std::initializer_list<std::string>& timeZones ){
	
	date::zoned_time startDate{date::current_zone(), localDay + h};
	date::zoned_time endDate{date::current_zone(), localDay + h + durationClass};
	std::cout << "Local time: [" << getMinutes(startDate) << ", "
	<< getMinutes(endDate) << "]" << '\n';
	
	longestStringSize = std::max(timeZones, [](const std::string& a,
	const std::string& b) { return a.size() < b.size(); }).size();
	for (auto timeZone: timeZones) {
		std::cout << " " << std::setw(longestStringSize + 1) << std::left
		          << timeZone
		          << "[" << getMinutes(date::zoned_time(timeZone, startDate))
		          << ", " << getMinutes(date::zoned_time(timeZone, endDate))
		          << "]" << '\n';
		
	}
}

int main() {

	using namespace std::string_literals;
	using namespace std::chrono;
	
	std::cout << '\n';
	
	constexpr auto classDay{date::year(2021)/2/1};
	constexpr auto durationClass = 4h;
	auto timeZones = {"America/Los_Angeles"s, "America/Denver"s,
					  "America/New_York"s, "Europe/London"s,
					  "Europe/Minsk"s, "Europe/Moscow"s,
					  "Asia/Kolkata"s, "Asia/Novosibirsk"s,
					  "Asia/Singapore"s, "Australia/Perth"s,
					  "Australia/Sydney"s};
	
	for (auto startTime: {7h, 13h, 17h}) {
		printStartEndTimes(date::local_days{classDay}, startTime,
						   durationClass, timeZones);
		std::cout << '\n';
	}

}
\end{lstlisting}

Before I dive into the functions getMinutes (line 8) and printStartEndTimes (line 13), let me say a few words about the main function. The main function defines the day of the class, the duration of the class, and all time zones. Finally, the range-based for loop (line 51) iterates through all potential starting points for an online class. Thanks to the function printStartEndTimes (line 13), all necessary information is displayed.

The few lines beginning with line 18 calculate the startDate and endDate of my training by adding the start time and the duration of the class to the calendar date. Both values are displayed with the help of the function getMinutes (line 8). floor<std::chrono::minutes>(zonedTime.get\_local\_time()) gets the stored timepoint out of the std::chrono::zoned\_time and truncates the value to the minute resolution. To properly align the output of the program, line 23 determines the size of the longest of all timezone names. Line 25 iterates through all time zones and displays the name of the time zone, and the beginning and end of each online class. A few calendar dates even cross the day boundaries.

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/28.png}\\
Displaying start and end times in various time zones
\end{center}


\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.3.3\hspace{0.2cm} New Clocks}

Beside the wall clock \href{https://www.modernescpp.com/index.php/the-three-clocks}{std::system\_clock}, the monotonic clock std::steady\_clock, and the most precise clock std::high\_resolution\_clock in C++11, C++20 supports five additional clocks.

\begin{itemize}
\item 
std::utc\_clock: Clock for the coordinated Universal Time (UTC). Measures the time since 00:00:00 UTC, 1 January 1970, including leap seconds.

\item 
std::tai\_clock: Clock for \href{https://en.wikipedia.org/wiki/International_Atomic_Time}{International Atomic Time} (TAI). Measure time since 00:00:00, 1 January 1958, and is offset 10 seconds ahead of UTC at that date. Leap seconds are not inserted.

\item 
std::gps\_clock: Clock for GPS time. It represents \href{https://en.wikipedia.org/wiki/Global_Positioning_System}{Global Positioning System} (GPS) time. It measures the time since 00:00:00, 6 January 1980 UTC. Leap seconds are not inserted.

\item 
std::file\_clock: Clock for file time. It’s an alias for \href{https://en.cppreference.com/w/cpp/filesystem/file_time_type}{std::filesystem::file\_time\_type}.

\item 
std::local\_t: Pseudo clock to represent local time.
\end{itemize}


\hspace*{\fill} \\ %插入空行
\noindent
\textbf{5.5.3.4\hspace{0.2cm} Chrono I/O}

Thanks to the function std::chrono::parse and the std::formatter from the formatting library, you can read and write chrono objects.

\begin{itemize}
\item 
std::chrono::parse: Parses a chrono object from a stream. \href{https://en.cppreference.com/w/cpp/chrono/parse}{cppreference.com/parse} gives you detailed infomation about the format string.

\item 
std::formatter: Defines specializations for the various chrono types. Read the details on the format specification on std::formatter here \href{https://en.cppreference.com/w/cpp/chrono/system_clock/formatter#Format_specification}{cppreference.com/formatter}.
\end{itemize}

\begin{tcolorbox}[breakable,enhanced jigsaw,colback=mygreen!5!white,colframe=mygreen!75!black,title={Distilled Information}]

\begin{itemize}
\item 
C++20 adds new components to the chrono library: time of day, calendar, and time zone.

\item 
Time of day is the time duration since midnight, split into hours, minutes, seconds, and fractional seconds.

\item 
Calendar stands for various calendar dates such as year, a month, a weekday, or the n-th day of a week.

\item 
 A time zone represents time specific to a geographic area.
\end{itemize}

\end{tcolorbox}

\newpage






