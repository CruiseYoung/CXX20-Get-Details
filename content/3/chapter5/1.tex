\begin{center}
\includegraphics[width=0.5\textwidth]{content/3/chapter5/images/2.png}\\
Cippi开启了流水作业
\end{center}

由于C++20中的范围库，使用标准模板库(STL)变得更加好用和强大。范围库使用惰性算法，可以直接在容器上工作，并且可以很容易地组合。简而言之:范围库的简单和强大基于其功能的思想。

在深入讨论细节之前，先来看一个范围库的例子:

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{结合transform和filter函数}
\begin{lstlisting}[style=styleCXX]
// rangesFilterTransform.cpp
#include <iostream>
#include <ranges>
#include <vector>
int main() {
	std::vector<int> numbers = {1, 2, 3, 4, 5, 6};
	auto results = numbers | std::views::filter([](int n){ return n % 2 == 0; })
						   | std::views::transform([](int n){ return n * 2; });
	for (auto v: results) std::cout << v << " "; // 4 8 12
}
\end{lstlisting}

必须从左到右读这个表达式。管道符号代表函数组合:首先，所有偶数都可以通过(std::views::filter([](int n)\{return n \% 2 == 0;\}))。在此之后，每个剩余的数字会映射到双倍功能上(std::views::transform([](int n)\{return n * 2;\}))。这个示例展示了范围库的两个新特性:可以将函数组合，应用于单个容器。

现在各位应该为细节做好准备了。让我们一起来了解一下:范围(range)和视图(view)。

\subsubsubsection{5.1.1\hspace{0.2cm}概念范围和视图}

在关于概念的章节中，我已经介绍了概念范围和视图。因此，这里有一个简短的复习。

\begin{itemize}
\item 
范围(range):范围是一组可以迭代的项，提供了一个开始迭代器和一个结束哨兵。当然，STL的容器也属于范围。
\end{itemize}

视图是在范围上执行的一些操作。视图不拥有数据，其复制、移动或赋值的时间复杂度恒定。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{在范围上操作的视图}
\begin{lstlisting}[style=styleCXX]
std::vector<int> numbers = {1, 2, 3, 4, 5, 6};
auto results = numbers | std::views::filter([](int n){ return n % 2 == 0; })
                       | std::views::transform([](int n){ return n * 2; });
\end{lstlisting}

这个代码片段中，numbers是范围，std::views::filter和std::views::transform是视图。

由于视图，C++20可以进行函数式编程。视图可以组合，并且是惰性的。我已经介绍了两种视图，但C++20提供了更多的视图。


\begin{center}
C++20中的视图
\end{center}

\begin{table}[H]
\centering
\begin{tabular}{ll}
视图                                                                                         & 描述                                              \\ \hline
\begin{tabular}[c]{@{}l@{}}std::views::all\_t\\ std::views::all\end{tabular}                 & 将范围转换为视图。                            \\
std::ranges::ref\_view                                                                       & 获取另一个范围中的所有元素。                     \\
\begin{tabular}[c]{@{}l@{}}std::ranges::filter\_view\\ std::views::filter\end{tabular}       & 获取满足谓词的元素。           \\
\begin{tabular}[c]{@{}l@{}}std::ranges::transform\_view\\ std::views::transform\end{tabular} & 变换每个元素。                                \\
\begin{tabular}[c]{@{}l@{}}std::ranges::take\_view\\ std::views::take\end{tabular}           & 获取另一个视图的前n个元素。              \\
\begin{tabular}[c]{@{}l@{}}std::ranges::take\_while\_view\\ std::views::take\_view\end{tabular} &
若谓词返回true，就获取另一个视图的元素。 \\
\begin{tabular}[c]{@{}l@{}}std::ranges.drop\_view\\ std::views::drop\end{tabular}            & 跳过另一个视图的前n个元素。              \\
\begin{tabular}[c]{@{}l@{}}std::ranges::drop\_while\_view\\ std::views::drop\_while\end{tabular} &
跳过另一个视图的初始元素，直到谓词返回false。 \\
\begin{tabular}[c]{@{}l@{}}std::ranges::split\_view\\ std::views::split\end{tabular}         & 使用分隔符拆分视图。                      \\
\begin{tabular}[c]{@{}l@{}}std::ranges::common\_view\\ std::views::common\end{tabular}       & 将一个视图转换为std::ranges::common\_range。       \\
\begin{tabular}[c]{@{}l@{}}std::ranges::reverse\_view\\ std::views::reverse\end{tabular}     & 倒序迭代视图。                               \\
\begin{tabular}[c]{@{}l@{}}std::ranges::basic\_istream\_view\\ std::ranges::istream\_view\end{tabular} &
输入流上应用操作符>{}>。 \\
\begin{tabular}[c]{@{}l@{}}std::ranges::elements\_view\\ std::veiws::elements\end{tabular}   & 对元组的第n个元素创建视图。            \\
\begin{tabular}[c]{@{}l@{}}std::ranges::keys\_view\\ std::views::keys\end{tabular}           & 对类似pair的第一个元素创建视图。 \\
\begin{tabular}[c]{@{}l@{}}std::ranges::values\_view\\ std::views::values\end{tabular} &
对类似pair的第二个元素创建视图。
\end{tabular}
\end{table}

通常，可以直接使用std::views::transform这样的视图，并将其命名为std::ranges:: transform\_view。

\subsubsubsection{5.1.2\hspace{0.2cm}直接在容器上使用}

标准模板库(STL)的算法有时有点不方便，同时需要开始和结束迭代器。有时，你并不想写这么多代码。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{STL的算法同时需要开始和结束迭代器}
\begin{lstlisting}[style=styleCXX]
// sortClassical.cpp

#include <algorithm>
#include <iostream>
#include <vector>

int main() {
	std::vector<int> myVec{-3, 5, 0, 7, -4};
	std::sort(myVec.begin(), myVec.end());
	for (auto v: myVec) std::cout << v << " "; // -4, -3, 0, 5, 7
}
\end{lstlisting}

若std::sort可以在整个容器上执行，这不是很好吗?因为范围库，这在C++20中是可能的。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{范围库的算法直接对容器进行操作}
\begin{lstlisting}[style=styleCXX]
// sortRanges.cpp

#include <algorithm>
#include <iostream>
#include <vector>

int main() {
	std::vector<int> myVec{-3, 5, 0, 7, -4};
	std::ranges::sort(myVec);
	for (auto v: myVec) std::cout << v << " "; // -4, -3, 0, 5, 7
}
\end{lstlisting}

\href{https://en.cppreference.com/w/cpp/algorithm}{算法库}的算法包含在\href{https://en.cppreference.com/w/cpp/header/algorithm}{<algorithm>}头文件中，例如std::sort，其有一个范围版本std::ranges::sort。

当了解std::ranges::sort的重载时，会注意到它们支持投影。

\hspace*{\fill} \\ %插入空行
\noindent
5.1.2.1\hspace{0.2cm}投影

std::ranges::sort有两个重载:

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{std::ranges::sort的重载}
\begin{lstlisting}[style=styleCXX]
template< std::random_access_iterator I, std::sentinel_for<I> S,
         class Comp = ranges::less, class Proj = std::identity >
requires std::sortable<I, Comp, Proj>
constexpr I sort( I first, S last, Comp comp = {}, Proj proj = {} );

template< ranges::random_access_range R, class Comp = ranges::less,
          class Proj = std::identity >
requires std::sortable<ranges::iterator_t<R>, Comp, Proj>
constexpr ranges::borrowed_iterator_t<R> sort( R&& r, Comp comp = {}, Proj proj = {}\
 );
\end{lstlisting}

当看到第二个重载时，会注意到它需要一个可排序范围R、一个谓词Comp和一个投影Proj。谓词Comp用于默认ranges::less，投影Proj用于恒等式。投影是集合到子集的映射，来说明一下这代表了什么:

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{数据类型——应用投影}
\begin{lstlisting}[style=styleCXX]
// rangeProjection.cpp

#include <algorithm>
#include <functional>
#include <iostream>
#include <vector>

struct PhoneBookEntry{
	std::string name;
	int number;
};

void printPhoneBook(const std::vector<PhoneBookEntry>& phoneBook) {
	for (const auto& entry: phoneBook) std::cout << "(" << entry.name << ", "
	                                                    << entry.number << ")";
	std::cout << "\n\n";
}

int main() {
	std::cout << '\n';
	
	std::vector<PhoneBookEntry> phoneBook{ {"Brown", 111}, {"Smith", 444},
		{"Grimm", 666}, {"Butcher", 222}, {"Taylor", 555}, {"Wilson", 333} };
	
	std::ranges::sort(phoneBook, {}, &PhoneBookEntry::name); // ascending by name
	printPhoneBook(phoneBook);
	
	std::ranges::sort(phoneBook, std::ranges::greater() ,
	                  &PhoneBookEntry::name); // descending by name
	printPhoneBook(phoneBook);
	
	std::ranges::sort(phoneBook, {}, &PhoneBookEntry::number); // ascending by number
	printPhoneBook(phoneBook);
	
	std::ranges::sort(phoneBook, std::ranges::greater(),
	                  &PhoneBookEntry::number); // descending by number
	printPhoneBook(phoneBook);
	
	std::cout << '\n';
}
\end{lstlisting}

phoneBook (line 23) has structs of type PhoneBookEntry (line 8). A PhoneBookEntry consists of a name and a number. Thanks to projections, the phoneBook can be sorted in ascending order by name (line 26), descending order by name (line 29), ascending order by number (line 33), and descending order by number (line 36).

\begin{center}
\includegraphics[width=1.0\textwidth]{content/3/chapter5/images/1-1.png}\\
Applying projections on data types
\end{center}

Most ranges algorithms support projections.

\hspace*{\fill} \\ %插入空行
\noindent
5.1.2.2\hspace{0.2cm} Direct Views on Keys and Values

Furthermore, you can create direct views on the keys (line 16) and the values (line 24) of a std::unordered\_map.

\hspace*{\fill} \\ %插入空行
\noindent
Views on the keys and the values of a std::unordered\_map
\begin{lstlisting}[style=styleCXX]
// rangesEntireContainer.cpp

#include <iostream>
#include <ranges>
#include <string>
#include <unordered_map>

int main() {

std::unordered_map<std::string, int> freqWord{ {"witch", 25}, {"wizard", 33},
												{"tale", 45}, {"dog", 4},
												{"cat", 34}, {"fish", 23} };

	std::cout << "Keys:" << '\n';
	auto names = std::views::keys(freqWord);
	for (const auto& name : names){ std::cout << name << " "; }
	std::cout << '\n';
	for (const auto& name : std::views::keys(freqWord)){ std::cout << name << " "; }
	
	std::cout << "\n\n";

	std::cout << "Values: " << '\n';
	auto values = std::views::values(freqWord);
	for (const auto& value : values){ std::cout << value << " "; }
	std::cout << '\n';
	for (const auto& value : std::views::values(freqWord)) {
		std::cout << value << " ";
	}

}
\end{lstlisting}

Of course, the keys and values can be displayed directly (lines 19 and 27). The output is identical.

\begin{tcblisting}{commandshell={}}
Keys:
fish cat dog tale wizard witch
fish cat dog tale wizard witch

Values:
23 34 4 45 33 25
23 34 4 45 33 25
\end{tcblisting}

\begin{center}
Views on the keys and values of a std::unordered\_map
\end{center}

Working directly on the container might be not so thrilling, but function composition and lazy evaluation are.

\subsubsubsection{5.1.3\hspace{0.2cm} Function Composition}

In the example rangesComposition.cpp, I use a std::map, because the ordering of the keys is crucial.

\hspace*{\fill} \\ %插入空行
\noindent
Composition of views
\begin{lstlisting}[style=styleCXX]
// rangesComposition.cpp

#include <iostream>
#include <ranges>
#include <string>
#include <map>

int main() {
	
	std::map<std::string, int> freqWord{ {"witch", 25}, {"wizard", 33},
										{"tale", 45}, {"dog", 4},
										{"cat", 34}, {"fish", 23} };
	
	std::cout << "All words: ";
	for (const auto& name : std::views::keys(freqWord)) { std::cout << name << " "; }
	
	std::cout << '\n';
	
	std::cout << "All words, reverses: ";
	for (const auto& name : std::views::keys(freqWord)
	                      | std::views::reverse) { std::cout << name << " "; }
	
	std::cout << '\n';
	
	std::cout << "The first 4 words: ";
	for (const auto& name : std::views::keys(freqWord)
	                      | std::views::take(4)) { std::cout << name << " "; }
	
	std::cout << '\n';
	
	std::cout << "All words starting with w: ";
	auto firstw = [](const std::string& name){ return name[0] == 'w'; };
	for (const auto& name : std::views::keys(freqWord)
	                      | std::views::filter(firstw)) { std::cout << name << " "; }
	
	std::cout << '\n';

}
\end{lstlisting}

I’m only interested in the keys. I display all of them (line 15), all of them reversed (line 20), the first four (line 26), and the keys starting with the letter ‘w’ (line 32).

Finally, here is the output of the program.

\begin{tcblisting}{commandshell={}}
All words: cat dog fish tale witch wizard
All words, reversed: wizard witch tale fish dog cat
The first 4 words: cat dog fish tale
All words starting with w: witch wizard
\end{tcblisting}

\begin{center}
Composition of views
\end{center}

The pipe symbol | is \href{https://en.wikipedia.org/wiki/Syntactic_sugar}{syntactic sugar} for function composition. Instead of C(R) you can write R | C. Consequently, the next three lines are equivalent.

\hspace*{\fill} \\ %插入空行
\noindent
Three syntactic forms of function composition
\begin{lstlisting}[style=styleCXX]
auto rev1 = std::views::reverse(std::views::keys(freqWord));
auto rev2 = std::views::keys(freqWord) | std::views::reverse;
auto rev3 = freqWord | std::views::keys | std::views::reverse;
\end{lstlisting}

\subsubsubsection{5.1.4\hspace{0.2cm} Lazy Evaluation}

std::views::iota is a range factory for creating a sequence of elements by successively incrementing an initial value. This sequence can be finite or infinite. The program rangesIota.cpp fills a std::vector with 10 int’s, starting with 0.

\hspace*{\fill} \\ %插入空行
\noindent
Using std::views::iota to fill a std::vector
\begin{lstlisting}[style=styleCXX]
// rangesIota.cpp

#include <iostream>
#include <numeric>
#include <ranges>
#include <vector>

int main() {
	
	std::cout << std::boolalpha;
	
	std::vector<int> vec;
	std::vector<int> vec2;
	
	for (int i: std::views::iota(0, 10)) vec.push_back(i);
	
	for (int i: std::views::iota(0) | std::views::take(10)) vec2.push_back(i);
	
	std::cout << "vec == vec2: " << (vec == vec2) << '\n';
	
	for (int i: vec) std::cout << i << " ";

}
\end{lstlisting}

The first iota call (line 15) creates all numbers from 0 to 9, incremented by 1. The second iota call (line 17) creates an infinite data stream, starting with 0, incremented by 1. std::views::iota(0) is lazy. I only get a new value if I ask for it. I ask for it ten times. Consequently, both vectors are identical.

\begin{tcblisting}{commandshell={}}
vec == vec2: true
0 1 2 3 4 5 6 7 8 9
\end{tcblisting}

\begin{center}
Using std::views::iota to fill a std::vector
\end{center}

Now, I want to solve a small challenge: finding the first 20 prime numbers starting with 1,000,000.

\hspace*{\fill} \\ %插入空行
\noindent
The first 20 prime numbers starting with 1’000’000
\begin{lstlisting}[style=styleCXX]
// rangesLazy.cpp

#include <iostream>
#include <ranges>

bool isPrime(int i) {
	for (int j=2; j*j <= i; ++j){
		if (i % j == 0) return false;
	}
	return true;
}

int main() {
	
	std::cout << "Numbers from 1'000'000 to 1'001'000 (displayed each 100th): "
	          << '\n';
	for (int i: std::views::iota(1'000'000, 1'001'000)) {
		if (i % 100 == 0) std::cout << i << " ";
	}
	
	std::cout << "\n\n";
	
	auto odd = [](int i){ return i % 2 == 1; };
	std::cout << "Odd numbers from 1'000'000 to 1'001'000 (displayed each 100th): "
	          << '\n';
	for (int i: std::views::iota(1'000'000, 1'001'000) | std::views::filter(odd)) {
		if (i % 100 == 1) std::cout << i << " ";
	}
	
	std::cout << "\n\n";
	std::cout << "Prime numbers from 1'000'000 to 1'001'000: " << '\n';
	for (int i: std::views::iota(1'000'000, 1'001'000) | std::views::filter(odd)
	                                                   | std::views::filter(isPrime)) {
		std::cout << i << " ";
	}
	
	std::cout << "\n\n";
	
	std::cout << "20 prime numbers starting with 1'000'000: " << '\n';
	for (int i: std::views::iota(1'000'000) | std::views::filter(odd)
	                                        | std::views::filter(isPrime)
	                                        | std::views::take(20)) {
		std::cout << i << " ";
	}
	
	std::cout << '\n';

}
\end{lstlisting}

This is my iterative strategy:

\begin{itemize}
\item 
line 18: Of course, I don’t know when I have 20 primes greater than 1000000. To be on the safe side, I create 1000 numbers. For obvious reasons, I displayed only each 100th.

\item 
line 27: I’m only interested in the odd numbers; therefore, I remove the even numbers.

\item 
line 34: Now, it’s time to apply the next filter. The predicate isPrime (line 7) returns if a number is prime. As you can see in the following screenshot, I was too eager. I got 75 primes.

\item 
line 42: Laziness is a virtue. I use std::iota as an infinite number factory, starting with 1000000 and ask precisely for 20 primes.
\end{itemize}

\begin{center}
\includegraphics[width=1.0\textwidth]{content/3/chapter5/images/1-2.png}\\
The first 20 prime numbers, starting with 1,000,000
\end{center}

\subsubsubsection{5.1.5\hspace{0.2cm} Define a View}

You can define your own view.

\hspace*{\fill} \\ %插入空行
\noindent
5.1.5.1\hspace{0.2cm} std::ranges::view\_interface

Thanks to the \href{https://en.cppreference.com/w/cpp/ranges/view_interface}{std::ranges::view\_interface} helper class, defining a view is easy. To fulfil the concept view, your view needs at least a default constructor, and member functions begin() and end():

\hspace*{\fill} \\ %插入空行
\noindent
Your own view
\begin{lstlisting}[style=styleCXX]
class MyView : public std::ranges::view_interface<MyView> {
public:
	auto begin() const { /*...*/ }
	auto end() const { /*...*/ }
};
\end{lstlisting}

By deriving MyView public from the helper class std::ranges::view\_interface using itself as a template parameter, MyView becomes a view. This technique of class template having itself as a template parameter is called \href{https://www.modernescpp.com/index.php/c-is-still-lazy}{Curiously Recurring Template Pattern} (short CRTP).

I use this technique in the next example to create a view out of a container of the Standard Template Library.

\hspace*{\fill} \\ %插入空行
\noindent
5.1.5.2\hspace{0.2cm} A Container View

The view ContainerView creates a view on an arbitrary container.

\noindent
Creating a view from a container
\begin{lstlisting}[style=styleCXX]
// containerView.cpp

#include <iostream>
#include <ranges>
#include <string>
#include <vector>

template<std::ranges::input_range Range>
requires std::ranges::view<Range>
class ContainerView : public std::ranges::view_interface<ContainerView<Range>> {
private:
	Range range_{};
	std::ranges::iterator_t<Range> begin_{ std::begin(range_) };
	std::ranges::iterator_t<Range> end_{ std::end(range_) };

public:
	ContainerView() = default;
	
	constexpr ContainerView(Range r): range_(std::move(r)) ,
									begin_(std::begin(r)), end_(std::end(r)) {}
	
	constexpr auto begin() const {
		return begin_;
	}
	constexpr auto end() const {
		return end_;
	}
};

template<typename Range>
ContainerView(Range&& range) -> ContainerView<std::ranges::views::all_t<Range>>;

int main() {

	std::vector<int> myVec{ 1, 2, 3, 4, 5, 6, 7, 8, 9};
	
	auto myContainerView = ContainerView(myVec);
	for (auto c : myContainerView) std::cout << c << " ";
	
	std::cout << '\n';
	
	for (auto i : std::views::reverse(ContainerView(myVec))) std::cout << i << ' ';
	std::cout << '\n';
	
	for (auto i : ContainerView(myVec) | std::views::reverse) std::cout << i << ' ';
	std::cout << '\n';
	
	std::cout << std::endl;
	
	std::string myStr = "Only for testing purpose.";
	
	auto myContainerView2 = ContainerView(myStr);
	for (auto c: myContainerView2) std::cout << c << " ";
	std::cout << '\n';
	
	for (auto i : std::views::reverse(ContainerView(myStr))) std::cout << i << ' ';
	std::cout << '\n';
	
	for (auto i : ContainerView(myStr) | std::views::reverse) std::cout << i << ' ';
	std::cout << '\n';

}
\end{lstlisting}

The class template ContainerView (line 8) derives from the helper class std::ranges::view\_interface and requires that the container support the concept std::ranges::view (line 9). The remaining, minimal implementation is straightforward. ContainerView has a default constructor (line 17), and the two required member functions begin() (line 22) and end() (line 25). For convenience, I added a user-defined deduction guide for class template argument deduction (line 32).

In the main function, I apply the ContainerView on a std::vector (line 37) and a std::string (line 49) and iterate through them forwards and backward.

\begin{center}
\includegraphics[width=0.6\textwidth]{content/3/chapter5/images/1-3.png}\\
Creating a view from a container
\end{center}

Let me add a few words to the class template argument deduction guide.

\begin{tcolorbox}[breakable,enhanced jigsaw,colback=blue!5!white,colframe=blue!75!black,title={Class Template Argument Deduction Guide}]
Since C++17, the compiler can deduce template parameters from template arguments. The template deduction guide is a pattern for the compiler to deduce the template arguments.

When you use ContainerView(myVec), the compiler applies the following user-defined deduction guide:

\hspace*{\fill} \\ %插入空行
\noindent
User-Defined Deduction Guide for ContainerView
\begin{lstlisting}[style=styleCXX]
template<class Range>
ContainerView(Range&& range) -> ContainerView<std::ranges::views::all_t<Range>>;
\end{lstlisting}

Essentially, a call Container(myVec) causes the compiler to instantiate the code on the right of the arrow ->:

\hspace*{\fill} \\ %插入空行
\noindent
Applying the deduction guide for Container(myVec)
\begin{lstlisting}[style=styleCXX]
ContainerView<std::ranges::views::all_t<std::vector<int>&>>(myVec);
\end{lstlisting}

\href{https://en.cppreference.com/w/cpp/language/class_template_argument_deduction}{cppreference.com} provides more information to the user-defined deduction guide for class templates.
\end{tcolorbox}

In the next section on the ranges library, I want to perform a small experiment. Can I add a flavor of Python into C++?

\subsubsubsection{5.1.6\hspace{0.2cm} A Flavor of Python}

The programming language \href{https://www.python.org/}{Python} has the convenient functions filter and map.

\begin{itemize}
\item 
filter: applies a predicate to all elements of an iterable and returns those elements for which the predicate returns true

\item 
map: applies a function to all elements of an iterable and returns a new iterable with the transformed elements
\end{itemize}

An iterable in C++ would be a type that you could use in a range-based for loop.

Furthermore, Python lets you combine both functions in a list comprehension.

\begin{itemize}
\item 
list comprehension: applies a filter and map phase to an iterable and returns a new iterable
\end{itemize}

Here is my challenge: I want to implement Python-like functions filter, map, and list comprehension in C++20 using the ranges library.

\hspace*{\fill} \\ %插入空行
\noindent
5.1.6.1\hspace{0.2cm} filter

Python’s filter function can be directly mapped to the corresponding ranges function.

\hspace*{\fill} \\ %插入空行
\noindent
Python’s filter function in C++
\begin{lstlisting}[style=styleCXX]
/ filterRanges.cpp

#include <iostream>
 #include <numeric>
 #include <ranges>
 #include <string>
 #include <vector>

template <typename Func, typename Seq>
auto filter(Func func, const Seq& seq) {

	typedef typename Seq::value_type value_type;
	
	std::vector<value_type> result{};
	for (auto i : seq | std::views::filter(func)) result.push_back(i);
	
	return result;
}


int main() {
	
	std::cout << '\n';
	
	std::vector<int> myInts(50);
	std::iota(myInts.begin(), myInts.end(), 1);
	auto res = filter([](int i){ return (i % 3) == 0; }, myInts);
	for (auto v: res) std::cout << v << " ";
	
	
	std::vector<std::string> myStrings{"Only", "for", "testing", "purposes"};
	auto res2 = filter([](const std::string& s){ return std::isupper(s[0]); },
	                       myStrings);
	
	std::cout << "\n\n";
	
	for (auto word: res2) std::cout << word << '\n';
	
	std::cout << '\n';

}
\end{lstlisting}

Before I write a few words about the program, let me show you the output.

\begin{tcblisting}{commandshell={}}
3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48

Only
\end{tcblisting}

\begin{center}
The filter function applied
\end{center}

The filter function (line 9) should be easy to read. Line 12 detects the type of the underlying element. I just apply the callable func to each element of the sequence and return the elements in the std::vector. Line 27 selects all numbers i from 1 to 50 for which (i \% 3) == 0 holds. Only the strings that start with an uppercase letter can pass the filter in line 32.

\hspace*{\fill} \\ %插入空行
\noindent
5.1.6.2\hspace{0.2cm} map

map applies a callable to each element of the input sequence.

\hspace*{\fill} \\ %插入空行
\noindent
Python’s map function in C++
\begin{lstlisting}[style=styleCXX]
/ mapRanges.cpp

#include <iostream>
#include <list>
#include <ranges>
#include <string>
#include <vector>
#include <utility>


template <typename Func, typename Seq>
auto map(Func func, const Seq& seq) {

	typedef typename Seq::value_type value_type;
	using return_type = decltype(func(std::declval<value_type>()));
	
	std::vector<return_type> result{};
	for (auto i :seq | std::views::transform(func)) result.push_back(i);
	
	return result;
}

int main() {

	std::cout << '\n';
	
	std::list<int> myInts{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	auto res = map([](int i){ return i * i; }, myInts);
	
	for (auto v: res) std::cout << v << " ";
	
	std::cout << "\n\n";
	
	std::vector<std::string> myStrings{"Only", "for", "testing", "purposes"};
	auto res2 = map([](const std::string& s){ return std::make_pair(s.size(), s); },
	                                                                myStrings);
	
	for (auto p: res2) std::cout << "(" << p.first << ", " << p.second << ") " ;
	
	std::cout << "\n\n";

}
\end{lstlisting}

Line 15 in the definition of the map function is quite interesting. The expression decltype(func( std::declval<value\_type>())) deduces the return\_type. The return\_type is the type to which all elements of the input sequence are transformed if the function func is applied to them. std::declval<value\_type>() returns an rvalue reference that decltype can use to deduce the type. This means the call map([](int i){ return i * i; }, myInts) (line 28) maps each element of myInt to its square and the call map([](const std::string\& s){ return std::make\_pair(s.size(), s); }, myStrings) maps each string of myStrings to a pair. The first element of each pair is the length of the string.

\begin{tcblisting}{commandshell={}}
1 4 9 16 25 36 49 64 81 100

(4, Only) (3, for) (7, testing) (8, purposes)
\end{tcblisting}

\begin{center}
The map function applied
\end{center}

\hspace*{\fill} \\ %插入空行
\noindent
5.1.6.3\hspace{0.2cm} List Comprehension

The program listComprehensionRanges.cpp has a simplified version of Python’s list-comprehension algorithm.

map applies a callable to each element of the input sequence.

\hspace*{\fill} \\ %插入空行
\noindent
A simplified variant of Python’s list comprehension in C++
\begin{lstlisting}[style=styleCXX]
// listComprehensionRanges.cpp

#include <algorithm>
#include <cctype>
#include <functional>
#include <iostream>
#include <ranges>
#include <string>
#include <vector>
#include <utility>

template <typename T>
struct AlwaysTrue {
	constexpr bool operator()(const T&) const {
		return true;
	}
};

template <typename Map, typename Seq, typename Filt = AlwaysTrue<
                                                      typename Seq::value_type>>
auto mapFilter(Map map, Seq seq, Filt filt = Filt()) {

	typedef typename Seq::value_type value_type;
	using return_type = decltype(map(std::declval<value_type>()));
	
	std::vector<return_type> result{};
	for (auto i :seq | std::views::filter(filt)
	                 | std::views::transform(map)) result.push_back(i);
	return result;
}

int main() {

	std::cout << '\n';
	
	std::vector myInts{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	
	auto res = mapFilter([](int i){ return i * i; }, myInts);
	for (auto v: res) std::cout << v << " ";
	
	std::cout << "\n\n";
	
	res = mapFilter([](int i){ return i * i; }, myInts,
	[](auto i){ return i % 2 == 1; });
	for (auto v: res) std::cout << v << " ";
	
	std::cout << "\n\n";
	
	std::vector<std::string> myStrings{"Only", "for", "testing", "purposes"};
	auto res2 = mapFilter([](const std::string& s){
	                          return std::make_pair(s.size(), s);
	                       }, myStrings);
	for (auto p: res2) std::cout << "(" << p.first << ", " << p.second << ") " ;
	
	std::cout << "\n\n";
	
	myStrings = {"Only", "for", "testing", "purposes"};
	res2 = mapFilter([](const std::string& s){
	                     return std::make_pair(s.size(), s);
	                 }, myStrings,
	                [](const std::string& word){ return std::isupper(word[0]); });
	
	for (auto p: res2) std::cout << "(" << p.first << ", " << p.second << ") " ;
	
	std::cout << "\n\n";

}
\end{lstlisting}

The default predicate that the filter function applies (line 19) always returns true (line 12). Always true means that the function mapFilter simply behaves by default as a map function. Consequently, the mapFilter function behaves in lines 37 and 49 as does the previous map function. Line 42 and 55 apply both functions map and filter in one call.

\begin{tcblisting}{commandshell={}}
1 4 9 16 25 36 49 64 81 100
	
1 9 25 49 81

(4, Only) (3, for) (7, testing) (8, purposes)

(4, Only)
\end{tcblisting}

\begin{center}
Both functions map and filter applied
\end{center}

\begin{tcolorbox}[breakable,enhanced jigsaw,colback=mygreen!5!white,colframe=mygreen!75!black,title={Distilled Information}]
\begin{itemize}
\item 
The ranges library provides us with an additional version of the STL algorithms. The ranges library algorithms are lazy, can work directly on containers and can be composed.

\item 
The algorithm of the ranges library
\begin{itemize}
\item 
are lazy and can, therefore, be invoked on infinite data streams.

\item 
can operate directly on the container and don’t need a range defined by two iterators.

\item 
can be composed using the pipe (|) symbol.
\end{itemize}
\end{itemize}
\end{tcolorbox}	
	
\newpage
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	