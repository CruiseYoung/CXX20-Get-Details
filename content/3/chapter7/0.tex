
After providing the theory to C++20, I now apply the theory in practice and provide you with a few case studies.

When you want to synchronize threads more than once, you can use condition variables, std::atomic\_flag, std::atomic<bool>, or semaphores. In the section fast synchronization of threads, I want to answer which variant is the fastest? The section on coroutines presented three coroutines, based on co\_return, co\_yield, and co\_await. I use these coroutines as a starting point for further experiments to deepen our understanding of the challenging control-flow of coroutines. In section variations of futures, I implement a lazy future and a future based on the future in section co\_return. Section modification and generalization of threads improves the generator from section co\_return, and, finally, section various job workflows discusses the job workflow, started in the section about co\_await.


